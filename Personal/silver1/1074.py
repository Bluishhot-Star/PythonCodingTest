
"""
# 문제
한수는 크기가 2^N x 2^N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2x2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.

N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.



재귀..
가장 큰 2x2 에서 내부로!
더이상 쪼개질 수 없을때까지 들어가기 (2x2)
(행, 열) 정보가 있어야함.. 
  0,0 -> 0,1 -> 1,0 -> 1,1
-> 0,2 -> 0,3 -> 1,2 -> 1,3


4개로 나누기
첫 기준점 2^N / 2   e.g. N = 3 -> 8 / (4, 4)가 기준점 -> 2^N / 2
기준점 == 4부분으로 나눴을때 4사분면의 시작점 (N / 2 + x, N / 2 + y)
원하는 위치가 기준점으로부터 왼위(-,-) 왼아(+,-) 오위(-,+) 오아(+,+) 영역 선택
영역별 카운트 추가 여부 = 현 기준점 (a,a) : 왼위 2^a * 0 / 오위 2^a * 1 / 왼아 2^a * 2 / 오아 2^a * 3 씩 추가됨
기준점 이동을 위한 prefix -> (0, 0), 오위 (0, +a/2) 왼아 (+a/2, 0) 오아(+a/2, +a/2)
"""

import sys

def solution (N, r, c):
  global x, y, cnt
  N = N//2 # 기준점 = N을 반으로 나누기 4,4

  # 기준점 기준 (행비교, 열비교)
  # 위왼 영역 (-,-)
  if r < N + x and c < N + y :
    cnt += 0
  # 위오 영역 (-,+=)
  elif r < N + x and c >= N + y :
    cnt += N * N * 1
    y += N
  # 아왼 영역 (+=,-)
  elif r >= N + x and c < N + y :
    cnt += N * N * 2
    x += N
  # 아오 영역 (+=,+=) -> 기준점 포함된 부분
  else :
    cnt += N * N * 3
    x += N
    y += N
  
  if N == 1 : return cnt

  return solution(N, r, c)


N, r, c = map(int, sys.stdin.readline().rstrip().split())
cnt = 0
x = 0
y = 0
ans = solution(2**N, r, c)
print(ans)